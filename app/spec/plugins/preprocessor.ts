/// <reference types="cypress" />

import Os from 'node:os';
import Path from 'node:path';
import esbuild, { BuildOptions } from 'esbuild';
import { Bunbun } from '@nodi/bunbun';

class Preprocessor {
    observers = new Map<string, () => void>();

    hasBeenChanged = true;

    builder?: esbuild.BuildResult;

    lastRes = '';

    constructor(
        private $: Bunbun<any>,
        private extendsOptions: BuildOptions,
    ) {}

    init = async () => {
        if (!this.hasBeenChanged) {
            return;
        }

        this.hasBeenChanged = false;

        const $ = this.$;

        await $.fs.ensureDir($.fs.resolve(Os.tmpdir(), './cypress-mx-temp'));

        const testFiles = await $.fs.list('./spec/src/**/*.{ts,tsx}');

        const entries = testFiles
            .map(x => this.fixPath(x))
            .map(x => [x, x.replace(/\.[a-z]+$/i, '')])
            .map(x => `register.set('${x[0]}', () => import('${x[1]}'));`)
            .sort((a, b) => a.localeCompare(b))
            .join('\n');

        const ef = await $.fs.read('./spec/entryFile.ts');

        const source = `
        /* DO NOT TOUCH THIS FILE */
        /* CONTENT HERE IS GENERATED BY CYPRESS PREPROCESSOR BY 🐧 */

        // @ts-nocheck

        const register = new Map();

        ${entries}

        (window as any).__cypres_mx_mod__run__ = (path: string) => register.get(path)?.();
        `.replace(/^\s+(\S)/gm, '$1');

        if (ef === source) {
            return;
        }

        await $.fs.write('./spec/entryFile.ts', source);
    };

    clearObservers = () => {
        Array.from(this.observers.values()).forEach(x => x());
    };

    build = async () => {
        if (this.builder) {
            return;
        }

        this.builder = await esbuild.build({
            ...this.extendsOptions,
            bundle: true,
            minify: true,
            write: true,
            format: 'iife',
            watch: {
                onRebuild: async () => {
                    this.lastRes = await this.$.fs.read(this.genTempPath(`./index.js`));
                    this.hasBeenChanged = true;
                    this.clearObservers();
                },
            },
            entryPoints: [this.$.fs.resolve('./spec/entryFile.ts')],
            outfile: this.genTempPath('./index.js'),
        });

        this.lastRes = await this.$.fs.read(this.genTempPath(`./index.js`));
    };

    genTempPath = (path: string) => this.$.fs
        .resolve(Os.tmpdir(), './cypress-mx-temp', path);

    pathToFlatName = (path: string) => this.fixPath(path)
        .replace(/[\.\/\\]/gi, '_');

    fixPath = (path: string) => Path
        .relative(Path.resolve(this.$.fs.cwd, './spec'), path)
        .replace(/[\\\/]/g, '/')
        .replace(/^\.?\/?/, './');

    createTempEntryFile = async (path: string) => {
        const flatName = this.pathToFlatName(path);
        const fixedPath = this.fixPath(path);
        const f = this.genTempPath(`./${flatName}.js`);

        await this.$.fs.write(f, `;;${this.lastRes};;__cypres_mx_mod__run__('${fixedPath}');;`);

        return f;
    };

    addObserver = (path: string, fn: () => void) => {
        const flatName = this.pathToFlatName(path);
        this.observers.set(flatName, fn);
    };

    removeObserver = (path: string) => {
        const flatName = this.pathToFlatName(path);
        this.observers.delete(flatName);

        if (this.observers.size === 0) {
            this.builder?.stop?.();
            this.builder = undefined;
        }
    };
}

export const preprocessor = async (extendsOptions: BuildOptions, $: Bunbun<any>) => {
    const pp = new Preprocessor($, extendsOptions);
    await pp.build();

    return async (fileObject: Cypress.FileObject) => {
        const path = fileObject.filePath;

        await pp.init();

        pp.addObserver(path, () => {
            fileObject.emit('rerun');
        });

        fileObject.on('close', () => {
            pp.removeObserver(path);
        });

        return await pp.createTempEntryFile(fileObject.filePath);
    };
};
